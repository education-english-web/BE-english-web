// Code generated by MockGen. DO NOT EDIT.
// Source: cronjob.go

// Package mock is a generated GoMock package.
package mock

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"

	cronjob "github.com/education-english-web/BE-english-web/pkg/cronjob"
)

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// Run mocks base method.
func (m *MockScheduler) Run(jobName string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", jobName)
	ret0, _ := ret[0].(error)
	return ret0
}

// Run indicates an expected call of Run.
func (mr *MockSchedulerMockRecorder) Run(jobName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockScheduler)(nil).Run), jobName)
}

// ScheduledJobs mocks base method.
func (m *MockScheduler) ScheduledJobs() map[string][]string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScheduledJobs")
	ret0, _ := ret[0].(map[string][]string)
	return ret0
}

// ScheduledJobs indicates an expected call of ScheduledJobs.
func (mr *MockSchedulerMockRecorder) ScheduledJobs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScheduledJobs", reflect.TypeOf((*MockScheduler)(nil).ScheduledJobs))
}

// Start mocks base method.
func (m *MockScheduler) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockSchedulerMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockScheduler)(nil).Start))
}

// Stop mocks base method.
func (m *MockScheduler) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockSchedulerMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockScheduler)(nil).Stop))
}

// MockScheduledJob is a mock of ScheduledJob interface.
type MockScheduledJob struct {
	ctrl     *gomock.Controller
	recorder *MockScheduledJobMockRecorder
}

// MockScheduledJobMockRecorder is the mock recorder for MockScheduledJob.
type MockScheduledJobMockRecorder struct {
	mock *MockScheduledJob
}

// NewMockScheduledJob creates a new mock instance.
func NewMockScheduledJob(ctrl *gomock.Controller) *MockScheduledJob {
	mock := &MockScheduledJob{ctrl: ctrl}
	mock.recorder = &MockScheduledJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduledJob) EXPECT() *MockScheduledJobMockRecorder {
	return m.recorder
}

// Job mocks base method.
func (m *MockScheduledJob) Job() cronjob.Job {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Job")
	ret0, _ := ret[0].(cronjob.Job)
	return ret0
}

// Job indicates an expected call of Job.
func (mr *MockScheduledJobMockRecorder) Job() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Job", reflect.TypeOf((*MockScheduledJob)(nil).Job))
}

// Schedules mocks base method.
func (m *MockScheduledJob) Schedules() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Schedules")
	ret0, _ := ret[0].([]string)
	return ret0
}

// Schedules indicates an expected call of Schedules.
func (mr *MockScheduledJobMockRecorder) Schedules() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Schedules", reflect.TypeOf((*MockScheduledJob)(nil).Schedules))
}

// MockJob is a mock of Job interface.
type MockJob struct {
	ctrl     *gomock.Controller
	recorder *MockJobMockRecorder
}

// MockJobMockRecorder is the mock recorder for MockJob.
type MockJobMockRecorder struct {
	mock *MockJob
}

// NewMockJob creates a new mock instance.
func NewMockJob(ctrl *gomock.Controller) *MockJob {
	mock := &MockJob{ctrl: ctrl}
	mock.recorder = &MockJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockJob) EXPECT() *MockJobMockRecorder {
	return m.recorder
}

// Name mocks base method.
func (m *MockJob) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockJobMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockJob)(nil).Name))
}

// Run mocks base method.
func (m *MockJob) Run() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Run")
}

// Run indicates an expected call of Run.
func (mr *MockJobMockRecorder) Run() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockJob)(nil).Run))
}
